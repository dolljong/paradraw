<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>좌표 그래프 생성기</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
        }
        h1 {
            margin: 0;
            padding: 10px 20px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #ddd;
            flex-shrink: 0;
        }
        #graph {
            border: 1px solid #ccc;
            display: block;
            background-color: #f9f9f9;
            width: 100%;
            height: calc(100% - 50px);
        }
        input, button, select {
            margin: 5px;
            padding: 5px;
        }
        #variableList, #coordinateList, #lineList {
            margin-top: 10px;
        }
        .axis line, .axis path {
            stroke: #ccc;
            display: none;
        }
        .axis text {
            display: none;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        .coordinate-label {
            font-size: 12px;
            pointer-events: none;
        }
        #graphInfo {
            width: 100%;
            height: 150px;
            margin-top: 10px;
            display: block;
            resize: vertical;
        }
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .left {
            flex: 1;
            min-width: 400px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #ddd;
        }
        .right {
            flex: 1;
            overflow-y: auto;
            padding: 10px 20px;
            max-width: 400px;
            height: 100%;
        }
        .right h2 {
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 16px;
        }
        .right h2:first-child {
            margin-top: 0;
        }
        .right textarea {
            width: 100%;
            box-sizing: border-box;
        }
        .right input,
        .right button {
            margin-bottom: 5px;
        }
        .graph-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            flex-shrink: 0;
        }
        .unit-selector {
            margin-left: 10px;
            font-size: 14px;
        }
        .button-group {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        .button-group button {
            flex: 1;
            min-width: 80px;
        }
        #variableList, #coordinateList, #lineList, #dimList {
            font-size: 12px;
            color: #666;
            margin: 5px 0 10px 0;
        }
    </style>
</head>
<body>
    <h1>변수로 도면 그리기(paradraw)</h1>
    <div class="container">
    <div class="left">
        <svg id="graph"></svg>
        <div class="graph-controls">
            <div style="display: flex; align-items: center; gap: 15px;">
                <div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showLabelsToggle" checked onchange="window.toggleLabels()">
                        <span class="slider"></span>
                    </label>
                    좌표이름 표시
                </div>
                <div>
                    치수축척: <input type="number" id="dimScaleInput" value="100" min="0.1" step="0.1" style="width: 60px;" onchange="window.setScale()">
                </div>
            </div>
            <button onclick="window.drawGraph()">도면그리기</button>
        </div>
    </div>
    <div class="right">
        <h2>변수 입력</h2>
        <textarea id="variableInput" rows="5" placeholder="변수명=값 형식으로 한 줄에 하나씩 입력&#10;; 뒤에 주석 가능&#10;예시:&#10;H1=2;높이1&#10;H2=3;높이2"></textarea>
        <button onclick="window.addVariables()">변수 적용</button>
        <div id="variableList"></div>

        <h2>좌표 계산 수식</h2>
        <textarea id="coordinateInput" rows="6" placeholder="점이름:x좌표,y좌표 형식&#10;; 뒤에 주석 가능&#10;예시:&#10;p1:0,0;원점&#10;p2:p1.x,p1.y+H1"></textarea>
        <button onclick="window.addCoordinates()">좌표 적용</button>
        <div id="coordinateList"></div>

        <h2>선 정보 입력</h2>
        <textarea id="lineInput" rows="4" placeholder="점들을 콤마로 연결&#10;예시: p1,p2,p3;외벽"></textarea>
        <button onclick="window.addLines()">선 적용</button>
        <div id="lineList"></div>

        <h2>치수선 정보 입력</h2>
        <textarea id="dimInput" rows="4" placeholder="타입,방향,점1,점2,...&#10;예시: HDIM,1,p1,p2;폭"></textarea>
        <button onclick="window.addDimensionLines()">치수선 적용</button>
        <div id="dimList"></div>

        <h2>데이터 관리</h2>
        <div class="button-group">
            <button onclick="window.printGraphInfo()">JSON보기</button>
            <button onclick="window.printTextInfo()">TEXT보기</button>
            <button onclick="window.readGraphInfo()">데이터 적용</button>
            <button onclick="window.loadExampleData()">예제 로드</button>
        </div>
        <div class="button-group">
            <button onclick="window.downloadData()">다운로드</button>
            <button onclick="document.getElementById('fileInput').click()">업로드</button>
            <input type="file" id="fileInput" accept=".json,.txt" style="display:none" onchange="window.uploadData(event)">
        </div>
        <textarea id="graphInfo" rows="6" placeholder="JSON 형식의 그래프 정보"></textarea>
    </div>
    </div>

    
    
    <script>
(function() {
    var variables = {};
    var variableComments = {};
    var userCoordinates = {};
    var coordinateComments = {};
    var calculatedCoordinates = {};
    var lines = [];
    var lineGroups = [];
    var dimensionLines = [];
    var svg, gContainer, labelContainer;
    var xScale, yScale;
    var zoom;
    var showLabels = true;

    function addVariables() {
        var input = document.getElementById('variableInput').value.trim();
        if (!input) {
            alert('변수를 입력해주세요.');
            return;
        }

        var inputLines = input.split('\n');
        var newVariables = {};
        var newComments = {};
        var errors = [];

        inputLines.forEach(function(line, index) {
            var originalLine = line.trim();
            if (!originalLine) return; // 빈 줄 무시

            // 세미콜론으로 분리하여 주석 추출
            var commentIndex = originalLine.indexOf(';');
            var comment = '';
            var codePart = originalLine;

            if (commentIndex !== -1) {
                comment = originalLine.substring(commentIndex + 1).trim();
                codePart = originalLine.substring(0, commentIndex).trim();
            }

            if (!codePart) return; // 주석만 있는 줄 무시

            var parts = codePart.split('=');
            if (parts.length !== 2) {
                errors.push(`${index + 1}번째 줄: 형식 오류 (변수명=값 형식으로 입력)`);
                return;
            }

            var name = parts[0].trim();
            var value = parseFloat(parts[1].trim());

            if (!name) {
                errors.push(`${index + 1}번째 줄: 변수명이 비어있습니다.`);
                return;
            }

            if (isNaN(value)) {
                errors.push(`${index + 1}번째 줄: '${parts[1].trim()}'은(는) 올바른 숫자가 아닙니다.`);
                return;
            }

            newVariables[name] = value;
            newComments[name] = comment;
        });

        if (errors.length > 0) {
            alert('오류:\n' + errors.join('\n'));
            return;
        }

        // 기존 변수에 새 변수 병합
        Object.assign(variables, newVariables);
        Object.assign(variableComments, newComments);
        updateVariableList();
        calculateCoordinates();
    }

    function updateVariableList() {
        // 텍스트박스에 현재 변수들을 주석과 함께 표시
        var textarea = document.getElementById('variableInput');
        var variableLines = Object.entries(variables).map(function([name, value]) {
            var comment = variableComments[name];
            if (comment) {
                return `${name}=${value};${comment}`;
            }
            return `${name}=${value}`;
        });
        textarea.value = variableLines.join('\n');

        // 변수 목록도 표시
        var list = document.getElementById('variableList');
        list.innerHTML = '변수 목록: ' +
            Object.entries(variables)
                .map(function([name, value], index) {
                    return `${index + 1}. ${name} = ${value}`;
                })
                .join(', ');
    }

    function addCoordinates() {
        var input = document.getElementById('coordinateInput').value.trim();
        if (!input) {
            alert('좌표를 입력해주세요.');
            return;
        }

        var inputLines = input.split('\n');
        var newCoordinates = {};
        var newComments = {};
        var errors = [];

        inputLines.forEach(function(line, index) {
            var trimmedLine = line.trim();
            if (!trimmedLine) return; // 빈 줄 무시

            // 세미콜론으로 주석 분리
            var commentIndex = trimmedLine.indexOf(';');
            var comment = '';
            var codePart = trimmedLine;

            if (commentIndex !== -1) {
                comment = trimmedLine.substring(commentIndex + 1).trim();
                codePart = trimmedLine.substring(0, commentIndex).trim();
            }

            if (!codePart) return; // 주석만 있는 줄 무시

            // 형식: 점이름:x좌표수식,y좌표수식
            var colonIndex = codePart.indexOf(':');
            if (colonIndex === -1) {
                errors.push(`${index + 1}번째 줄: 형식 오류 (점이름:x좌표수식,y좌표수식 형식으로 입력)`);
                return;
            }

            var name = codePart.substring(0, colonIndex).trim();
            var formulaPart = codePart.substring(colonIndex + 1).trim();

            if (!name) {
                errors.push(`${index + 1}번째 줄: 좌표 이름이 비어있습니다.`);
                return;
            }

            // 첫 번째 콤마를 기준으로 x, y 분리
            var commaIndex = formulaPart.indexOf(',');
            if (commaIndex === -1) {
                errors.push(`${index + 1}번째 줄: x좌표와 y좌표를 콤마로 구분해주세요.`);
                return;
            }

            var xFormula = formulaPart.substring(0, commaIndex).trim();
            var yFormula = formulaPart.substring(commaIndex + 1).trim();

            if (!xFormula || !yFormula) {
                errors.push(`${index + 1}번째 줄: x좌표 또는 y좌표 수식이 비어있습니다.`);
                return;
            }

            newCoordinates[name] = { x: xFormula, y: yFormula };
            newComments[name] = comment;
        });

        if (errors.length > 0) {
            alert('오류:\n' + errors.join('\n'));
            return;
        }

        // 기존 좌표를 새 좌표로 교체
        userCoordinates = newCoordinates;
        coordinateComments = newComments;
        updateCoordinateList();
        updateCoordinateSelects();
        calculateCoordinates();
        drawGraph();
    }

    function calculateCoordinates() {
        calculatedCoordinates = {};
        for (let [name, coord] of Object.entries(userCoordinates)) {
            try {
                let x = evaluateFormula(coord.x, calculatedCoordinates);
                let y = evaluateFormula(coord.y, calculatedCoordinates);
                
                if (typeof x !== 'number' || typeof y !== 'number' || isNaN(x) || isNaN(y)) {
                    throw new Error('계산 결과가 유효한 숫자가 아닙니다.');
                }
                
                calculatedCoordinates[name] = { x: x, y: y };
            } catch (error) {
                console.error(`Error calculating coordinate ${name}: ${error.message}`);
                calculatedCoordinates[name] = { x: NaN, y: NaN };
            }
        }
        updateCoordinateList();
        // console.log('Calculated coordinates:', calculatedCoordinates);
    }

    function updateCoordinateList() {
        // 텍스트박스에 현재 좌표들을 주석과 함께 표시
        var textarea = document.getElementById('coordinateInput');
        var coordinateLines = Object.entries(userCoordinates).map(function([name, coord]) {
            var comment = coordinateComments[name];
            if (comment) {
                return `${name}:${coord.x},${coord.y};${comment}`;
            }
            return `${name}:${coord.x},${coord.y}`;
        });
        textarea.value = coordinateLines.join('\n');

        // 좌표 목록도 표시 (계산된 값 포함)
        var list = document.getElementById('coordinateList');
        list.innerHTML = '좌표 목록: ' +
            Object.entries(userCoordinates)
                .map(function([name, coord], index) {
                    var calc = calculatedCoordinates[name];
                    var calcStr = calc ? ` = (${calc.x.toFixed(2)}, ${calc.y.toFixed(2)})` : '';
                    return `${index + 1}. ${name}(${coord.x}, ${coord.y})${calcStr}`;
                })
                .join('<br>');
    }

    function evaluateFormula(formula, calculatedPoints) {
        formula = formula.replace(/(\w+)\.([xy])/g, function(match, point, coord) {
            if (calculatedPoints[point] && !isNaN(calculatedPoints[point][coord])) {
                return calculatedPoints[point][coord];
            }
            throw new Error(`유효하지 않은 좌표 참조: ${match}`);
        });

        formula = formula.replace(/\b([A-Za-z_]\w*)\b/g, function(match) {
            if (variables.hasOwnProperty(match)) {
                return variables[match];
            }
            return match;
        });

        var context = Object.assign({}, Math);
        
        try {
            var result = new Function('return ' + formula).call(context);
            if (typeof result !== 'number' || isNaN(result)) {
                throw new Error('계산 결과가 유효한 숫자가 아닙니다.');
            }
            return result;
        } catch (error) {
            throw new Error("수식 '" + formula + "' 계산 중 오류 발생: " + error.message);
        }
    }

    var dimensions = {
        "HDIM": "Horizontal Dimension",
        "VDIM": "Vertical Dimension",
        "ADIM": "Angular Dimension"
    };

    function updateDimSelects() {
        var dimtypeSelect = document.getElementById('dimtype');
        dimtypeSelect.innerHTML = '';
        Object.keys(dimensions).forEach(function(name) {
            dimtypeSelect.add(new Option(dimensions[name], name));
        });
    }

    function updateCoordinateSelects() {
        // 더 이상 select 박스를 사용하지 않음
    }

    function addLines() {
        var input = document.getElementById('lineInput').value.trim();
        if (!input) {
            alert('선 정보를 입력해주세요.');
            return;
        }

        var inputLines = input.split('\n');
        var newLines = [];
        var newLineGroups = [];
        var errors = [];

        inputLines.forEach(function(line, index) {
            var trimmedLine = line.trim();
            if (!trimmedLine) return; // 빈 줄 무시

            // 세미콜론으로 주석 분리
            var commentIndex = trimmedLine.indexOf(';');
            var comment = '';
            var codePart = trimmedLine;

            if (commentIndex !== -1) {
                comment = trimmedLine.substring(commentIndex + 1).trim();
                codePart = trimmedLine.substring(0, commentIndex).trim();
            }

            if (!codePart) return; // 주석만 있는 줄 무시

            var points = codePart.split(',').map(p => p.trim()).filter(p => p !== '');

            if (points.length < 2) {
                errors.push(`${index + 1}번째 줄: 최소 2개 이상의 점을 입력해주세요.`);
                return;
            }

            // 존재하지 않는 좌표 확인
            var invalidPoints = points.filter(p => !userCoordinates.hasOwnProperty(p));
            if (invalidPoints.length > 0) {
                errors.push(`${index + 1}번째 줄: 존재하지 않는 좌표 - ${invalidPoints.join(', ')}`);
                return;
            }

            // 선 그룹 저장
            newLineGroups.push({ points: points, comment: comment });

            // 연속된 점들을 선으로 변환
            for (var i = 0; i < points.length - 1; i++) {
                newLines.push({ start: points[i], end: points[i + 1] });
            }
        });

        if (errors.length > 0) {
            alert('오류:\n' + errors.join('\n'));
            return;
        }

        lines = newLines;
        lineGroups = newLineGroups;
        updateLineList();
        drawGraph();
    }

    function updateLineList() {
        // lineGroups를 텍스트박스에 주석과 함께 표시
        var textarea = document.getElementById('lineInput');
        var lineTexts = lineGroups.map(function(group) {
            if (group.comment) {
                return `${group.points.join(',')};${group.comment}`;
            }
            return group.points.join(',');
        });
        textarea.value = lineTexts.join('\n');

        // 선 목록도 표시
        var list = document.getElementById('lineList');
        list.innerHTML = '선 목록: ' +
            lines.map(function(line, index) {
                return `${index + 1}. ${line.start} -> ${line.end}`;
            }).join('<br>');
    }

    function addDimensionLines() {
        var input = document.getElementById('dimInput').value.trim();
        if (!input) {
            alert('치수선 정보를 입력해주세요.');
            return;
        }

        var inputLines = input.split('\n');
        var newDimensionLines = [];
        var errors = [];
        var validTypes = ['HDIM', 'VDIM', 'ADIM'];

        inputLines.forEach(function(line, index) {
            var trimmedLine = line.trim();
            if (!trimmedLine) return; // 빈 줄 무시

            // 세미콜론으로 주석 분리
            var commentIndex = trimmedLine.indexOf(';');
            var comment = '';
            var codePart = trimmedLine;

            if (commentIndex !== -1) {
                comment = trimmedLine.substring(commentIndex + 1).trim();
                codePart = trimmedLine.substring(0, commentIndex).trim();
            }

            if (!codePart) return; // 주석만 있는 줄 무시

            var parts = codePart.split(',').map(p => p.trim());

            if (parts.length < 4) {
                errors.push(`${index + 1}번째 줄: 형식 오류 (타입,방향,점1,점2,... 형식으로 입력)`);
                return;
            }

            var type = parts[0].toUpperCase();
            var direction = parseInt(parts[1]);
            var points = parts.slice(2).filter(p => p !== '');

            if (!validTypes.includes(type)) {
                errors.push(`${index + 1}번째 줄: 유효하지 않은 타입 '${parts[0]}' (HDIM, VDIM, ADIM 중 선택)`);
                return;
            }

            if (direction !== 1 && direction !== -1) {
                errors.push(`${index + 1}번째 줄: 방향은 1 또는 -1이어야 합니다.`);
                return;
            }

            if (points.length < 2) {
                errors.push(`${index + 1}번째 줄: 최소 2개 이상의 점을 입력해주세요.`);
                return;
            }

            var invalidPoints = points.filter(p => !userCoordinates.hasOwnProperty(p));
            if (invalidPoints.length > 0) {
                errors.push(`${index + 1}번째 줄: 존재하지 않는 좌표 - ${invalidPoints.join(', ')}`);
                return;
            }

            newDimensionLines.push({
                type: type,
                points: points,
                direction: direction,
                comment: comment
            });
        });

        if (errors.length > 0) {
            alert('오류:\n' + errors.join('\n'));
            return;
        }

        dimensionLines = newDimensionLines;
        updateDimensionLineList();
        drawGraph();
    }

    function updateDimensionLineList() {
        // 텍스트박스에 현재 치수선들을 주석과 함께 표시
        var textarea = document.getElementById('dimInput');
        var dimLines = dimensionLines.map(function(line) {
            var base = `${line.type},${line.direction},${line.points.join(',')}`;
            if (line.comment) {
                return `${base};${line.comment}`;
            }
            return base;
        });
        textarea.value = dimLines.join('\n');

        // 치수선 목록도 표시
        var list = document.getElementById('dimList');
        list.innerHTML = '치수선 목록: ' +
            dimensionLines.map(function(line, index) {
                return `${index + 1}. ${dimensions[line.type]}: ${line.points.join(' -> ')} (${line.direction > 0 ? '정방향' : '역방향'})`;
            }).join('<br>');
    }

    function drawGraph() {
        calculateCoordinates();
        
        svg = d3.select("#graph");
        svg.selectAll("*").remove();

        var svgBounds = svg.node().getBoundingClientRect();
        var width = svgBounds.width;
        var height = svgBounds.height;
        var margin = { top: 20, right: 20, bottom: 20, left: 20 };
        var graphWidth = width - margin.left - margin.right;
        var graphHeight = height - margin.top - margin.bottom;

        svg.attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio", "xMidYMid meet");

        var domain = calculateDomain();

        // xScale과 yScale의 동일한 비율 설정
        var maxRange = Math.max(graphWidth, graphHeight);
        var xScaleRange = [0, maxRange];
        var yScaleRange = [maxRange, 0];

        xScale = d3.scaleLinear().domain(domain.x).range(xScaleRange);
        yScale = d3.scaleLinear().domain(domain.y).range(yScaleRange);

        // xScale = d3.scaleLinear().domain(domain.x).range([0, graphWidth]);
        // yScale = d3.scaleLinear().domain(domain.y).range([graphHeight, 0]);

        gContainer = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // 축 그리기
        drawAxes();

        // 줌 기능 설정
        zoom = d3.zoom()
            .scaleExtent([0.1, 100])
            .on("zoom", zoomed);

        svg.call(zoom);

        // 자동 zoom 조정
        autoZoom();

        // 모든 요소 그리기
        drawAllElements();
    }

    function drawAxes() {
        gContainer.append("g")
            .attr("class", "x-axis axis")
            .attr("transform", `translate(0,${yScale(0)})`)
            .call(d3.axisBottom(xScale).tickSize(0));
        gContainer.append("g")
            .attr("class", "y-axis axis")
            .attr("transform", `translate(${xScale(0)},0)`)
            .call(d3.axisLeft(yScale).tickSize(0));
    }

    function drawAllElements() {
        drawCoordinates();
        drawLines();
        drawDimensionLines();
    }

    function drawCoordinates() {
        gContainer.selectAll(".coordinate-group").remove();

        var dimScale = parseFloat(document.getElementById('dimScaleInput').value) || 1;
        var defaultTextHeight = 2.5; // 도면 단위 기본값
        var textHeightInUnits = defaultTextHeight * dimScale;

        // 도면 단위를 픽셀로 변환
        var pixelsPerUnit = Math.abs(xScale(1) - xScale(0));
        var fontSize = textHeightInUnits * pixelsPerUnit;
        var pointRadius = 0.5 * dimScale * pixelsPerUnit; // 직경 1 * dimScale
        var textOffset = textHeightInUnits * pixelsPerUnit * 0.8;

        Object.entries(calculatedCoordinates).forEach(function([name, coord]) {
            if (!isNaN(coord.x) && !isNaN(coord.y)) {
                var point = gContainer.append("g")
                    .attr("class", "coordinate-group")
                    .attr("transform", `translate(${xScale(coord.x)},${yScale(coord.y)})`);

                point.append("circle")
                    .attr("r", pointRadius)
                    .attr("fill", "black")
                    .attr("class", "coordinate-point")
                    .style("vector-effect", "non-scaling-stroke");

                point.append("text")
                    .attr("dy", -textOffset + "px")
                    .text(name)
                    .attr("class", "coordinate-label")
                    .style("text-anchor", "middle")
                    .style("font-size", fontSize + "px");
            }
        });
    }


    function drawLines() {
        gContainer.selectAll(".graph-line").remove();

        lines.forEach(function(line) {
            var start = calculatedCoordinates[line.start];
            var end = calculatedCoordinates[line.end];
            if (start && end && !isNaN(start.x) && !isNaN(start.y) && !isNaN(end.x) && !isNaN(end.y)) {
                gContainer.append("line")
                    .attr("class", "graph-line")
                    .attr("x1", xScale(start.x))
                    .attr("y1", yScale(start.y))
                    .attr("x2", xScale(end.x))
                    .attr("y2", yScale(end.y))
                    .attr("stroke", "blue")
                    .attr("stroke-width", 1 / zoom.transform.k)
                    .style("vector-effect", "non-scaling-stroke");
            }
        });
    }

    function drawDimensionLines() {
    gContainer.selectAll(".dimension-line, .dimension-text").remove();

    var currentZoom = zoom.transform ? zoom.transform.k : 1;
    var defaultOffset = 20;
    var dimScale = parseFloat(document.getElementById('dimScaleInput').value) || 1;

    dimensionLines.forEach(function(line) {
        if (!Array.isArray(line.points) || line.points.length < 2) {
            console.error('Invalid points for dimension line:', line.points);
            return;
        }

        var points = line.points.map(p => calculatedCoordinates[p]);
        if (points.some(p => !p || isNaN(p.x) || isNaN(p.y))) {
            console.error(`Invalid calculated coordinates for points: ${line.points}`);
            return;
        }

        var direction = typeof line.direction === 'number' ? line.direction : 1;
        var offset = defaultOffset * dimScale;

        if (line.type === 'HDIM') {
            drawHorizontalDimension(points, direction, offset);
        } else if (line.type === 'VDIM') {
            drawVerticalDimension(points, direction, offset);
        } else if (line.type === 'ADIM') {
            drawAngularDimension(points, direction, offset);
        } else {
            console.error(`Invalid dimension type: ${line.type}`);
        }
    });
}

    function drawArrowHead(group, x, y, angle, direction) {
        var arrowSize = 5;
        var arrowAngle = Math.PI / 6; // 30도

        // 화살표의 두 점 계산
        var x1 = x - arrowSize * Math.cos(angle * Math.PI / 180 - arrowAngle);
        var y1 = y - arrowSize * Math.sin(angle * Math.PI / 180 - arrowAngle);
        var x2 = x - arrowSize * Math.cos(angle * Math.PI / 180 + arrowAngle);
        var y2 = y - arrowSize * Math.sin(angle * Math.PI / 180 + arrowAngle);

        group.append("path")
            .attr("d", `M${x},${y} L${x1},${y1} L${x2},${y2} Z`)
            .attr("fill", "black")
            .attr("stroke", "none");
    }

    function drawEndpoint(group, x, y) {
        var dimScale = parseFloat(document.getElementById('dimScaleInput').value) || 1;
        var pixelsPerUnit = Math.abs(xScale(1) - xScale(0));
        var radius = 0.5 * dimScale * pixelsPerUnit; // 직경 1 * dimScale

        group.append("circle")
            .attr("cx", x)
            .attr("cy", y)
            .attr("r", radius)
            .attr("fill", "black");
    }

    function drawHorizontalDimension(points, direction, offset) {
    if (!Array.isArray(points) || points.length < 2) {
        console.error('drawHorizontalDimension: Invalid points', points);
        return;
    }

    var y = points[0].y;
    var textY = y + offset * direction;

    // 도면 단위로 텍스트 크기 계산
    var dimScale = parseFloat(document.getElementById('dimScaleInput').value) || 1;
    var defaultTextHeight = 2.5;
    var textHeightInUnits = defaultTextHeight * dimScale;
    var pixelsPerUnit = Math.abs(xScale(1) - xScale(0));
    var fontSize = textHeightInUnits * pixelsPerUnit;

    var strokeWidth = 1;

    // 모든 점의 x 좌표 수집
    var xCoords = points.map(p => p.x);

    // 치수보조선 시작 오프셋 (원점에서 10 * dimScale 떨어진 곳에서 시작)
    var extensionGap = 10 * dimScale;
    var extensionStartY = y + extensionGap * direction;

    // 각 점에서 치수선까지 수직선 그리기 (원점에서 gap만큼 떨어진 곳에서 시작)
    xCoords.forEach(x => {
        gContainer.append("line")
            .attr("class", "dimension-line")
            .attr("x1", xScale(x))
            .attr("y1", yScale(extensionStartY))
            .attr("x2", xScale(x))
            .attr("y2", yScale(textY))
            .attr("stroke", "red")
            .attr("stroke-width", strokeWidth)
            .style("vector-effect", "non-scaling-stroke");
    });

    // 전체 수평선 그리기
    var xMin = Math.min(...xCoords);
    var xMax = Math.max(...xCoords);
    gContainer.append("line")
        .attr("class", "dimension-line")
        .attr("x1", xScale(xMin))
        .attr("y1", yScale(textY))
        .attr("x2", xScale(xMax))
        .attr("y2", yScale(textY))
        .attr("stroke", "red")
        .attr("stroke-width", strokeWidth)
        .style("vector-effect", "non-scaling-stroke");

    // 연속된 점 쌍마다 텍스트 추가
    for (var i = 0; i < points.length - 1; i++) {
        var x1 = points[i].x;
        var x2 = points[i + 1].x;
        var midX = (x1 + x2) / 2;

        gContainer.append("text")
            .attr("class", "dimension-text")
            .attr("x", xScale(midX))
            .attr("y", yScale(textY))
            .attr("dy", "-0.5em")
            .text(Math.round(Math.abs(x2 - x1)))
            .attr("text-anchor", "middle")
            .attr("fill", "black")
            .style("font-size", `${fontSize}px`);
    }

    // 각 점에 끝점 표시
    xCoords.forEach(x => {
        drawEndpoint(gContainer, xScale(x), yScale(textY));
    });
}

function drawVerticalDimension(points, direction, offset) {
    if (!Array.isArray(points) || points.length < 2) {
        console.error('drawVerticalDimension: Invalid points', points);
        return;
    }

    var x = points[0].x;
    var textX = x + offset * direction;

    // 도면 단위로 텍스트 크기 계산
    var dimScale = parseFloat(document.getElementById('dimScaleInput').value) || 1;
    var defaultTextHeight = 2.5;
    var textHeightInUnits = defaultTextHeight * dimScale;
    var pixelsPerUnit = Math.abs(xScale(1) - xScale(0));
    var fontSize = textHeightInUnits * pixelsPerUnit;

    var strokeWidth = 1;

    // 모든 점의 y 좌표 수집
    var yCoords = points.map(p => p.y);

    var scaledTextX = xScale(textX);

    // 치수보조선 시작 오프셋 (원점에서 10 * dimScale 떨어진 곳에서 시작)
    var extensionGap = 10 * dimScale;
    var extensionStartX = x + extensionGap * direction;

    // 각 점에서 치수선까지 수평선 그리기 (원점에서 gap만큼 떨어진 곳에서 시작)
    yCoords.forEach(y => {
        gContainer.append("line")
            .attr("class", "dimension-line")
            .attr("x1", xScale(extensionStartX))
            .attr("y1", yScale(y))
            .attr("x2", scaledTextX)
            .attr("y2", yScale(y))
            .attr("stroke", "red")
            .attr("stroke-width", strokeWidth)
            .style("vector-effect", "non-scaling-stroke");
    });

    // 전체 수직선 그리기
    var yMin = Math.min(...yCoords);
    var yMax = Math.max(...yCoords);
    gContainer.append("line")
        .attr("class", "dimension-line")
        .attr("x1", scaledTextX)
        .attr("y1", yScale(yMin))
        .attr("x2", scaledTextX)
        .attr("y2", yScale(yMax))
        .attr("stroke", "red")
        .attr("stroke-width", strokeWidth)
        .style("vector-effect", "non-scaling-stroke");

    // 연속된 점 쌍마다 텍스트 추가
    for (var i = 0; i < points.length - 1; i++) {
        var y1 = points[i].y;
        var y2 = points[i + 1].y;
        var midY = (y1 + y2) / 2;
        var scaledMidY = yScale(midY);

        gContainer.append("text")
            .attr("class", "dimension-text")
            .attr("x", scaledTextX)
            .attr("y", scaledMidY)
            .attr("transform", `rotate(-90, ${scaledTextX}, ${scaledMidY}) translate(0, ${direction > 0 ? -5 : 5})`)
            .text(Math.round(Math.abs(y2 - y1)))
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .attr("fill", "black")
            .style("font-size", `${fontSize}px`);
    }

    // 각 점에 끝점 표시
    yCoords.forEach(y => {
        drawEndpoint(gContainer, scaledTextX, yScale(y));
    });
}


function drawAngularDimension(points, direction, offset) {
    if (!Array.isArray(points) || points.length < 2) {
        console.error('drawAngularDimension: Invalid points', points);
        return;
    }

    var p1 = points[0];
    var p2 = points[1];

    // 두 점 사이의 각도 계산
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    var angle = Math.atan2(dy, dx);

    // 두 점 사이의 실제 거리
    var distance = Math.sqrt(dx * dx + dy * dy);

    // 치수선 offset 방향 (선에 수직 방향)
    var perpAngle = angle + Math.PI / 2;
    var offsetX = offset * direction * Math.cos(perpAngle);
    var offsetY = offset * direction * Math.sin(perpAngle);

    // 치수선의 두 끝점
    var dimP1 = { x: p1.x + offsetX, y: p1.y + offsetY };
    var dimP2 = { x: p2.x + offsetX, y: p2.y + offsetY };

    // 도면 단위로 텍스트 크기 계산
    var dimScale = parseFloat(document.getElementById('dimScaleInput').value) || 1;
    var defaultTextHeight = 2.5;
    var textHeightInUnits = defaultTextHeight * dimScale;
    var pixelsPerUnit = Math.abs(xScale(1) - xScale(0));
    var fontSize = textHeightInUnits * pixelsPerUnit;

    var strokeWidth = 1;

    // 치수보조선 시작 오프셋 (원점에서 10 * dimScale 떨어진 곳에서 시작)
    var extensionGap = 10 * dimScale;
    var gapX = extensionGap * direction * Math.cos(perpAngle);
    var gapY = extensionGap * direction * Math.sin(perpAngle);

    // 치수보조선 시작점 (원점에서 gap만큼 떨어진 곳)
    var extStart1 = { x: p1.x + gapX, y: p1.y + gapY };
    var extStart2 = { x: p2.x + gapX, y: p2.y + gapY };

    // 원점에서 치수선까지 연결선 그리기 (gap만큼 떨어진 곳에서 시작)
    [{ from: extStart1, to: dimP1 }, { from: extStart2, to: dimP2 }].forEach(function(line) {
        gContainer.append("line")
            .attr("class", "dimension-line")
            .attr("x1", xScale(line.from.x))
            .attr("y1", yScale(line.from.y))
            .attr("x2", xScale(line.to.x))
            .attr("y2", yScale(line.to.y))
            .attr("stroke", "red")
            .attr("stroke-width", strokeWidth)
            .style("vector-effect", "non-scaling-stroke");
    });

    // 치수선 그리기
    gContainer.append("line")
        .attr("class", "dimension-line")
        .attr("x1", xScale(dimP1.x))
        .attr("y1", yScale(dimP1.y))
        .attr("x2", xScale(dimP2.x))
        .attr("y2", yScale(dimP2.y))
        .attr("stroke", "red")
        .attr("stroke-width", strokeWidth)
        .style("vector-effect", "non-scaling-stroke");

    // 텍스트 위치 (치수선 중앙)
    var textX = (dimP1.x + dimP2.x) / 2;
    var textY = (dimP1.y + dimP2.y) / 2;

    // 텍스트 회전 각도 (degree)
    var textAngle = angle * 180 / Math.PI;
    // 텍스트가 뒤집어지지 않도록 조정
    if (textAngle > 90 || textAngle < -90) {
        textAngle += 180;
    }

    // 텍스트 추가
    gContainer.append("text")
        .attr("class", "dimension-text")
        .attr("x", xScale(textX))
        .attr("y", yScale(textY))
        .attr("transform", `rotate(${-textAngle}, ${xScale(textX)}, ${yScale(textY)})`)
        .attr("dy", "-0.5em")
        .text(Math.round(distance))
        .attr("text-anchor", "middle")
        .attr("fill", "black")
        .style("font-size", `${fontSize}px`);

    // 끝점 표시
    drawEndpoint(gContainer, xScale(dimP1.x), yScale(dimP1.y));
    drawEndpoint(gContainer, xScale(dimP2.x), yScale(dimP2.y));
}

function zoomed(event) {
    if (!event.transform) {
        console.error("Zoom event transform is undefined");
        return;
    }

    gContainer.attr("transform", event.transform);

    // 축 업데이트
    gContainer.select(".x-axis").call(d3.axisBottom(event.transform.rescaleX(xScale)).tickSize(0));
    gContainer.select(".y-axis").call(d3.axisLeft(event.transform.rescaleY(yScale)).tickSize(0));

    // 모든 요소 다시 그리기
    drawAllElements();
}


function calculateDomain() {
    var allPoints = Object.values(calculatedCoordinates).filter(point => point && !isNaN(point.x) && !isNaN(point.y));
    
    if (allPoints.length === 0) return { x: [-10, 10], y: [-10, 10] };

    var xExtent = d3.extent(allPoints, d => d.x);
    var yExtent = d3.extent(allPoints, d => d.y);

    var xPadding = Math.max((xExtent[1] - xExtent[0]) * 0.1, 1);
    var yPadding = Math.max((yExtent[1] - yExtent[0]) * 0.1, 1);

    return {
        x: [xExtent[0] - xPadding, xExtent[1] + xPadding],
        y: [yExtent[0] - yPadding, yExtent[1] + yPadding]
    };
}

function autoZoom() {
    var domain = calculateDomain();
    var svgBounds = svg.node().getBoundingClientRect();
    var width = svgBounds.width;
    var height = svgBounds.height;
    var margin = 40; // 여백

    var xRange = domain.x[1] - domain.x[0];
    var yRange = domain.y[1] - domain.y[0];

    // 바운딩박스에 맞게 스케일 계산
    var scaleX = (width - margin * 2) / (xScale(domain.x[1]) - xScale(domain.x[0]));
    var scaleY = (height - margin * 2) / (yScale(domain.y[0]) - yScale(domain.y[1]));
    var scale = Math.min(scaleX, scaleY);
    scale = Math.max(scale, 0.001); // 최소 스케일 보장

    var centerX = (domain.x[0] + domain.x[1]) / 2;
    var centerY = (domain.y[0] + domain.y[1]) / 2;

    var transform = d3.zoomIdentity
        .translate(width / 2, height / 2)
        .scale(scale)
        .translate(-xScale(centerX), -yScale(centerY));

    svg.transition().duration(750).call(zoom.transform, transform);
}

function setScale() {
    if (svg && zoom) {
        drawGraph();
    }
}




function toggleLabels() {
    showLabels = document.getElementById('showLabelsToggle').checked;
    d3.selectAll('.coordinate-label, .coordinate-point').style('display', showLabels ? 'inline' : 'none');
}

function printGraphInfo() {
    var graphInfo = {
        variables: variables,
        variableComments: variableComments,
        coordinates: userCoordinates,
        coordinateComments: coordinateComments,
        calculatedCoordinates: calculatedCoordinates,
        lines: lines,
        lineGroups: lineGroups,
        dimensionLines: dimensionLines
    };

    var jsonString = JSON.stringify(graphInfo, null, 2);
    document.getElementById('graphInfo').value = jsonString;
}

function printTextInfo() {
    var textLines = [];

    // 변수 정보
    textLines.push('=== 변수 ===');
    Object.entries(variables).forEach(function([name, value]) {
        var comment = variableComments[name] ? ' ; ' + variableComments[name] : '';
        textLines.push(name + ' = ' + value + comment);
    });

    // 좌표 정보
    textLines.push('');
    textLines.push('=== 좌표 ===');
    Object.entries(userCoordinates).forEach(function([name, coord]) {
        var calc = calculatedCoordinates[name];
        var calcStr = calc ? ' => (' + calc.x + ', ' + calc.y + ')' : '';
        var comment = coordinateComments[name] ? ' ; ' + coordinateComments[name] : '';
        textLines.push(name + ': ' + coord.x + ', ' + coord.y + calcStr + comment);
    });

    // 선 정보
    textLines.push('');
    textLines.push('=== 선 ===');
    lineGroups.forEach(function(group, index) {
        var comment = group.comment ? ' ; ' + group.comment : '';
        textLines.push((index + 1) + '. ' + group.points.join(' -> ') + comment);
    });

    // 치수선 정보
    textLines.push('');
    textLines.push('=== 치수선 ===');
    dimensionLines.forEach(function(dim, index) {
        var typeNames = { 'HDIM': '수평', 'VDIM': '수직', 'ADIM': '경사' };
        var typeName = typeNames[dim.type] || dim.type;
        var dirStr = dim.direction > 0 ? '정방향' : '역방향';
        var comment = dim.comment ? ' ; ' + dim.comment : '';
        textLines.push((index + 1) + '. [' + typeName + '/' + dirStr + '] ' + dim.points.join(' -> ') + comment);
    });

    document.getElementById('graphInfo').value = textLines.join('\n');
}

function downloadData() {
    var content = document.getElementById('graphInfo').value.trim();
    if (!content) {
        alert('다운로드할 데이터가 없습니다. JSON보기 또는 TEXT보기를 먼저 클릭하세요.');
        return;
    }

    var isJson = content.startsWith('{');
    var extension = isJson ? 'json' : 'txt';
    var mimeType = isJson ? 'application/json' : 'text/plain';
    var filename = 'paradraw_data.' + extension;

    var blob = new Blob([content], { type: mimeType + ';charset=utf-8' });
    var url = URL.createObjectURL(blob);

    var a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function uploadData(event) {
    var file = event.target.files[0];
    if (!file) return;

    var reader = new FileReader();
    reader.onload = function(e) {
        document.getElementById('graphInfo').value = e.target.result;
        readGraphInfo();
    };
    reader.readAsText(file);

    // 같은 파일을 다시 선택할 수 있도록 초기화
    event.target.value = '';
}

function loadExampleData(silent) {
    var exampleData = {
        "variables": {
            "H1": 2000,
            "H2": 3000,
            "H3": 1200,
            "B1": 2500,
            "B2": 2000,
            "B3": 1200,
            "B4": 500
        },
        "variableComments": {
            "H1": "흉벽높이",
            "H2": "벽체높이",
            "H3": "기초두께",
            "B1": "뒷굽폭",
            "B2": "벽체두께",
            "B3": "앞굽폭",
            "B4": "흉벽두께"
        },
        "coordinates": {
            "p1": { "x": "0", "y": "0" },
            "p2": { "x": "p1.x", "y": "p1.y-H1" },
            "p3": { "x": "p2.x+B2-B4", "y": "p2.y" },
            "p4": { "x": "p3.x", "y": "p3.y-H2" },
            "p5": { "x": "p4.x+B3", "y": "p4.y" },
            "p6": { "x": "p5.x", "y": "p5.y-H3" },
            "p7": { "x": "p6.x-B3-B2-B1", "y": "p6.y" },
            "p8": { "x": "p7.x", "y": "p7.y+H3" },
            "p9": { "x": "p8.x+B1", "y": "p8.y" },
            "p10": { "x": "p9.x", "y": "p1.y" }
        },
        "calculatedCoordinates": {
            "p1": { "x": 0, "y": 0 },
            "p2": { "x": 0, "y": -2000 },
            "p3": { "x": 1500, "y": -2000 },
            "p4": { "x": 1500, "y": -5000 },
            "p5": { "x": 2700, "y": -5000 },
            "p6": { "x": 2700, "y": -6200 },
            "p7": { "x": -3000, "y": -6200 },
            "p8": { "x": -3000, "y": -5000 },
            "p9": { "x": -500, "y": -5000 },
            "p10": { "x": -500, "y": 0 }
        },
        "lines": [
            { "start": "p1", "end": "p2" },
            { "start": "p2", "end": "p3" },
            { "start": "p3", "end": "p4" },
            { "start": "p4", "end": "p5" },
            { "start": "p5", "end": "p6" },
            { "start": "p6", "end": "p7" },
            { "start": "p7", "end": "p8" },
            { "start": "p8", "end": "p9" },
            { "start": "p9", "end": "p10" },
            { "start": "p10", "end": "p1" }
        ],
        "dimensionLines": [
            { "type": "HDIM", "points": ["p6", "p7"], "direction": -1 },
            { "type": "HDIM", "points": ["p8", "p9"], "direction": 1 },
            { "type": "HDIM", "points": ["p9", "p4"], "direction": 1 },
            { "type": "HDIM", "points": ["p4", "p5"], "direction": 1 },
            { "type": "HDIM", "points": ["p10", "p1"], "direction": 1 },
            { "type": "HDIM", "points": ["p1", "p3"], "direction": 1 },
            { "type": "VDIM", "points": ["p6", "p1"], "direction": 1 }
        ]
    };

    // 예제 데이터를 텍스트 영역에 표시
    document.getElementById('graphInfo').value = JSON.stringify(exampleData, null, 2);

    // 데이터 읽기 함수 호출
    readGraphInfo(silent);
}

function readGraphInfo(silent) {
    var inputText = document.getElementById('graphInfo').value.trim();

    // JSON인지 TEXT인지 판단 (첫 문자가 {이면 JSON)
    if (inputText.startsWith('{')) {
        readJsonData(inputText, silent);
    } else {
        readTextData(inputText, silent);
    }
}

function readJsonData(jsonString, silent) {
    try {
        var graphInfo = JSON.parse(jsonString);

        variables = graphInfo.variables || {};
        variableComments = graphInfo.variableComments || {};
        userCoordinates = graphInfo.coordinates || {};
        coordinateComments = graphInfo.coordinateComments || {};
        calculatedCoordinates = graphInfo.calculatedCoordinates || {};
        lines = graphInfo.lines || [];
        dimensionLines = graphInfo.dimensionLines || [];

        // lineGroups 처리: 있으면 사용, 없으면 lines에서 생성
        if (graphInfo.lineGroups && graphInfo.lineGroups.length > 0) {
            lineGroups = graphInfo.lineGroups;
        } else {
            // 기존 lines 배열에서 lineGroups 생성
            lineGroups = [];
            if (lines.length > 0) {
                var currentGroup = { points: [lines[0].start, lines[0].end], comment: '' };
                for (var i = 1; i < lines.length; i++) {
                    if (lines[i].start === currentGroup.points[currentGroup.points.length - 1]) {
                        currentGroup.points.push(lines[i].end);
                    } else {
                        lineGroups.push(currentGroup);
                        currentGroup = { points: [lines[i].start, lines[i].end], comment: '' };
                    }
                }
                lineGroups.push(currentGroup);
            }
        }

        applyLoadedData(silent, 'JSON');
    } catch (error) {
        console.error('JSON 파싱 에러:', error);
        if (!silent) {
            alert('JSON 데이터를 읽는 중 오류가 발생했습니다. 올바른 형식인지 확인해주세요.');
        }
    }
}

function readTextData(textContent, silent) {
    try {
        var newVariables = {};
        var newVariableComments = {};
        var newCoordinates = {};
        var newCoordinateComments = {};
        var newLineGroups = [];
        var newDimensionLines = [];

        var currentSection = '';
        var lines_text = textContent.split('\n');

        lines_text.forEach(function(line) {
            var trimmedLine = line.trim();
            if (!trimmedLine) return;

            // 섹션 헤더 확인 (치수선을 선보다 먼저 체크해야 함)
            if (trimmedLine.startsWith('===')) {
                if (trimmedLine.includes('변수')) currentSection = 'variables';
                else if (trimmedLine.includes('좌표')) currentSection = 'coordinates';
                else if (trimmedLine.includes('치수선')) currentSection = 'dimensions';
                else if (trimmedLine.includes('선')) currentSection = 'lines';
                return;
            }

            // 섹션별 파싱
            if (currentSection === 'variables') {
                // 형식: name = value ; comment
                var match = trimmedLine.match(/^(\w+)\s*=\s*([^\s;]+)\s*(?:;\s*(.*))?$/);
                if (match) {
                    newVariables[match[1]] = parseFloat(match[2]);
                    newVariableComments[match[1]] = match[3] || '';
                }
            } else if (currentSection === 'coordinates') {
                // 형식: name: x, y => (calcX, calcY) ; comment
                var match = trimmedLine.match(/^(\w+):\s*([^,]+),\s*([^=>;]+)(?:\s*=>.*)?(?:\s*;\s*(.*))?$/);
                if (match) {
                    newCoordinates[match[1]] = { x: match[2].trim(), y: match[3].trim() };
                    newCoordinateComments[match[1]] = match[4] || '';
                }
            } else if (currentSection === 'lines') {
                // 형식: 1. p1 -> p2 -> p3 ; comment
                var match = trimmedLine.match(/^\d+\.\s*(.+?)(?:\s*;\s*(.*))?$/);
                if (match) {
                    var points = match[1].split('->').map(p => p.trim());
                    newLineGroups.push({ points: points, comment: match[2] || '' });
                }
            } else if (currentSection === 'dimensions') {
                // 형식: 1. [수평/정방향] p1 -> p2 ; comment
                var match = trimmedLine.match(/^\d+\.\s*\[([^\]\/]+)\/([^\]]+)\]\s*(.+?)(?:\s*;\s*(.*))?$/);
                if (match) {
                    var typeMap = { '수평': 'HDIM', '수직': 'VDIM', '경사': 'ADIM' };
                    var type = typeMap[match[1]] || 'HDIM';
                    var direction = match[2] === '정방향' ? 1 : -1;
                    var points = match[3].split('->').map(p => p.trim());
                    newDimensionLines.push({ type: type, direction: direction, points: points, comment: match[4] || '' });
                }
            }
        });

        variables = newVariables;
        variableComments = newVariableComments;
        userCoordinates = newCoordinates;
        coordinateComments = newCoordinateComments;
        lineGroups = newLineGroups;
        dimensionLines = newDimensionLines;

        // lineGroups에서 lines 생성
        lines = [];
        lineGroups.forEach(function(group) {
            for (var i = 0; i < group.points.length - 1; i++) {
                lines.push({ start: group.points[i], end: group.points[i + 1] });
            }
        });

        applyLoadedData(silent, 'TEXT');
    } catch (error) {
        console.error('TEXT 파싱 에러:', error);
        if (!silent) {
            alert('TEXT 데이터를 읽는 중 오류가 발생했습니다. 올바른 형식인지 확인해주세요.');
        }
    }
}

function applyLoadedData(silent, format) {
    updateVariableList();
    updateCoordinateList();
    updateCoordinateSelects();
    updateLineList();
    updateDimensionLineList();
    calculateCoordinates();
    drawGraph();

    if (!silent) {
        alert(format + ' 데이터를 성공적으로 읽어 적용했습니다.');
    }
}

// 전역 객체에 함수 할당
window.addVariables = addVariables;
window.updateVariableList = updateVariableList;
window.addCoordinates = addCoordinates;
window.updateCoordinateList = updateCoordinateList;
window.updateCoordinateSelects = updateCoordinateSelects;
window.addLines = addLines;
window.addDimensionLines = addDimensionLines;
window.updateLineList = updateLineList;
window.drawGraph = drawGraph;
window.toggleLabels = toggleLabels;
window.setScale = setScale;
window.printGraphInfo = printGraphInfo;
window.printTextInfo = printTextInfo;
window.downloadData = downloadData;
window.uploadData = uploadData;
window.readGraphInfo = readGraphInfo;
window.loadExampleData = loadExampleData;

// 초기화 함수
function init() {
    loadExampleData(true);
}

// 페이지 로드 시 초기화
window.onload = init;
})();

</script>
    </body>
    </html>