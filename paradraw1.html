<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ParaDraw </title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
        }
        h1 {
            margin: 0;
            padding: 10px 20px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #ddd;
            flex-shrink: 0;
        }
        #graph {
            border: 1px solid #ccc;
            display: block;
            background-color: #f9f9f9;
            width: 100%;
            height: calc(100% - 50px);
        }
        input, button, select {
            margin: 5px;
            padding: 5px;
        }
        #parseResult {
            margin-top: 10px;
        }
        .axis line, .axis path {
            stroke: #ccc;
            display: none;
        }
        .axis text {
            display: none;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        .coordinate-label {
            font-size: 12px;
            pointer-events: none;
        }
        #graphInfo {
            width: 100%;
            height: 150px;
            margin-top: 10px;
            display: block;
            resize: vertical;
        }
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .left {
            flex: 1;
            min-width: 400px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #ddd;
        }
        .right {
            flex: 1;
            overflow-y: auto;
            padding: 10px 20px;
            max-width: 400px;
            height: 100%;
        }
        .right h2 {
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 16px;
        }
        .right h2:first-child {
            margin-top: 0;
        }
        .right textarea {
            width: 100%;
            box-sizing: border-box;
        }
        .right input,
        .right button {
            margin-bottom: 5px;
        }
        .graph-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            flex-shrink: 0;
        }
        .unit-selector {
            margin-left: 10px;
            font-size: 14px;
        }
        .button-group {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        .button-group button {
            flex: 1;
            min-width: 80px;
        }
        #parseResult {
            font-size: 12px;
            color: #666;
            margin: 5px 0 10px 0;
        }
    </style>
</head>
<body>
    <h1>변수로 도면 그리기(paradraw)</h1>
    <div class="container">
    <div class="left">
        <svg id="graph"></svg>
        <div class="graph-controls">
            <div style="display: flex; align-items: center; gap: 15px;">
                <div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showLabelsToggle" checked onchange="window.toggleLabels()">
                        <span class="slider"></span>
                    </label>
                    좌표이름 표시
                </div>
                <div>
                    치수축척: <input type="number" id="dimScaleInput" value="100" min="0.1" step="0.1" style="width: 60px;" onchange="window.setScale()">
                </div>
            </div>
            <button onclick="window.applyAndDraw()">도면그리기</button>
        </div>
    </div>
    <div class="right">
        <h2>입력</h2>
        <textarea id="mainInput" rows="15" placeholder="변수: H1=2000;높이&#10;좌표: p1=0,0;원점&#10;      p2=p1.x,p1.y+H1&#10;반복: s[0-N]=i*100,i*200&#10;선:   line,p1,p2,p3;외벽&#10;순차: line,p1..p10&#10;치수: HDIM,1,p1,p2;폭"></textarea>
        <div id="parseResult"></div>

        <h2>데이터 관리</h2>
        <div class="button-group">
            <button onclick="window.printGraphInfo()">JSON보기</button>
            <button onclick="window.printTextInfo()">TEXT보기</button>
            <button onclick="window.readGraphInfo()">데이터 적용</button>
            <select id="exampleSelect" style="flex:1;min-width:80px;">
                <option value="retaining">교대 단면</option>
                <option value="sine">SIN 곡선</option>
                <option value="circle">원 곡선</option>
                <option value="heart">하트 곡선</option>
            </select>
            <button onclick="window.loadExampleData()">예제 로드</button>
        </div>
        <div class="button-group">
            <button onclick="window.downloadData()">다운로드</button>
            <button onclick="document.getElementById('fileInput').click()">업로드</button>
            <input type="file" id="fileInput" accept=".json,.txt" style="display:none" onchange="window.uploadData(event)">
        </div>
        <textarea id="graphInfo" rows="6" placeholder="JSON 형식의 그래프 정보"></textarea>
    </div>
    </div>

    
    
    <script>
(function() {
    var variables = {};
    var variableComments = {};
    var userCoordinates = {};
    var coordinateComments = {};
    var calculatedCoordinates = {};
    var lines = [];
    var lineGroups = [];
    var dimensionLines = [];
    var svg, gContainer, labelContainer;
    var xScale, yScale;
    var zoom;
    var showLabels = true;

    function applyAndDraw() {
        parseAllInput();
        drawGraph();
    }

    function parseAllInput() {
        var input = document.getElementById('mainInput').value.trim();

        var newVariables = {};
        var newVariableComments = {};
        var coordLines = [];
        var lineInputs = [];
        var dimInputs = [];

        if (input) {
            input.split('\n').forEach(function(line) {
                var trimmed = line.trim();
                if (!trimmed) return;

                var commentIndex = trimmed.indexOf(';');
                var comment = '';
                var codePart = trimmed;
                if (commentIndex !== -1) {
                    comment = trimmed.substring(commentIndex + 1).trim();
                    codePart = trimmed.substring(0, commentIndex).trim();
                }
                if (!codePart) return;

                var firstToken = codePart.split(/[,\s]/)[0].toUpperCase();

                if (firstToken === 'LINE') {
                    lineInputs.push({ codePart: codePart, comment: comment });
                    return;
                }
                if (firstToken === 'HDIM' || firstToken === 'VDIM' || firstToken === 'ADIM') {
                    dimInputs.push({ codePart: codePart, comment: comment });
                    return;
                }

                var eqIndex = codePart.indexOf('=');
                if (eqIndex === -1) return;

                var name = codePart.substring(0, eqIndex).trim();
                var valuePart = codePart.substring(eqIndex + 1).trim();

                if (findTopLevelComma(valuePart) !== -1) {
                    coordLines.push(trimmed);
                } else {
                    var value = parseFloat(valuePart);
                    if (name && !isNaN(value)) {
                        newVariables[name] = value;
                        newVariableComments[name] = comment;
                    }
                }
            });
        }

        variables = newVariables;
        variableComments = newVariableComments;

        // 좌표 범위 확장 및 파싱
        var newCoordinates = {};
        var newCoordinateComments = {};
        if (coordLines.length > 0) {
            var expandedCoordText = expandCoordinateRanges(coordLines.join('\n'));
            expandedCoordText.split('\n').forEach(function(line) {
                var trimmed = line.trim();
                if (!trimmed) return;
                var ci = trimmed.indexOf(';');
                var comment = '';
                var codePart = trimmed;
                if (ci !== -1) {
                    comment = trimmed.substring(ci + 1).trim();
                    codePart = trimmed.substring(0, ci).trim();
                }
                if (!codePart) return;
                var eqIdx = codePart.indexOf('=');
                if (eqIdx === -1) return;
                var name = codePart.substring(0, eqIdx).trim();
                var formulaPart = codePart.substring(eqIdx + 1).trim();
                var commaIdx = findTopLevelComma(formulaPart);
                if (commaIdx === -1) return;
                var xFormula = formulaPart.substring(0, commaIdx).trim();
                var yFormula = formulaPart.substring(commaIdx + 1).trim();
                if (xFormula && yFormula) {
                    newCoordinates[name] = { x: xFormula, y: yFormula };
                    newCoordinateComments[name] = comment;
                }
            });
        }
        userCoordinates = newCoordinates;
        coordinateComments = newCoordinateComments;
        calculateCoordinates();

        // 선 파싱
        var newLines = [];
        var newLineGroups = [];
        lineInputs.forEach(function(item) {
            var pointsPart = item.codePart.replace(/^line[\s,]*/i, '');
            var expandedCode = expandPointRanges(expandPointSequence(pointsPart));
            var points = expandedCode.split(',').map(function(p) { return p.trim(); }).filter(function(p) { return p !== ''; });
            if (points.length >= 2) {
                newLineGroups.push({ points: points, comment: item.comment });
                for (var i = 0; i < points.length - 1; i++) {
                    newLines.push({ start: points[i], end: points[i + 1] });
                }
            }
        });
        lines = newLines;
        lineGroups = newLineGroups;

        // 치수선 파싱
        var newDimensionLines = [];
        dimInputs.forEach(function(item) {
            var expandedCode = expandPointRanges(expandPointSequence(item.codePart));
            var parts = expandedCode.split(',').map(function(p) { return p.trim(); });
            if (parts.length >= 4) {
                var type = parts[0].toUpperCase();
                var direction = parseInt(parts[1]);
                var points = parts.slice(2).filter(function(p) { return p !== ''; });
                if ((direction === 1 || direction === -1) && points.length >= 2) {
                    newDimensionLines.push({ type: type, points: points, direction: direction, comment: item.comment });
                }
            }
        });
        dimensionLines = newDimensionLines;

        updateParseResult();
    }

    function updateParseResult() {
        var result = document.getElementById('parseResult');
        var html = '';

        var varEntries = Object.entries(variables);
        if (varEntries.length > 0) {
            html += '<b>변수:</b> ' + varEntries.map(function([name, value], i) {
                return (i + 1) + '. ' + name + '=' + value;
            }).join(', ') + '<br>';
        }

        var coordEntries = Object.entries(userCoordinates);
        if (coordEntries.length > 0) {
            html += '<b>좌표(' + coordEntries.length + '개):</b> ' + coordEntries.map(function([name, coord], i) {
                var calc = calculatedCoordinates[name];
                var calcStr = calc && !isNaN(calc.x) ? ' = (' + calc.x.toFixed(1) + ', ' + calc.y.toFixed(1) + ')' : '';
                return (i + 1) + '. ' + name + calcStr;
            }).join(', ') + '<br>';
        }

        if (lineGroups.length > 0) {
            html += '<b>선:</b> ' + lineGroups.map(function(g, i) {
                return (i + 1) + '. ' + g.points[0] + '→' + g.points[g.points.length - 1] + '(' + g.points.length + '점)';
            }).join(', ') + '<br>';
        }

        if (dimensionLines.length > 0) {
            var dims = { 'HDIM': '수평', 'VDIM': '수직', 'ADIM': '경사' };
            html += '<b>치수선:</b> ' + dimensionLines.map(function(dim, i) {
                return (i + 1) + '. ' + dims[dim.type] + ' ' + dim.points.join('→');
            }).join(', ');
        }

        result.innerHTML = html;
    }

    function updateMainInput() {
        var textLines = [];
        Object.entries(variables).forEach(function([name, value]) {
            var comment = variableComments[name] ? ';' + variableComments[name] : '';
            textLines.push(name + '=' + value + comment);
        });
        Object.entries(userCoordinates).forEach(function([name, coord]) {
            var comment = coordinateComments[name] ? ';' + coordinateComments[name] : '';
            textLines.push(name + '=' + coord.x + ',' + coord.y + comment);
        });
        lineGroups.forEach(function(group) {
            var comment = group.comment ? ';' + group.comment : '';
            textLines.push('line,' + group.points.join(',') + comment);
        });
        dimensionLines.forEach(function(dim) {
            var comment = dim.comment ? ';' + dim.comment : '';
            textLines.push(dim.type + ',' + dim.direction + ',' + dim.points.join(',') + comment);
        });
        document.getElementById('mainInput').value = textLines.join('\n');
    }

    function calculateCoordinates() {
        calculatedCoordinates = {};
        for (let [name, coord] of Object.entries(userCoordinates)) {
            try {
                let x = evaluateFormula(coord.x, calculatedCoordinates);
                let y = evaluateFormula(coord.y, calculatedCoordinates);

                if (typeof x !== 'number' || typeof y !== 'number' || isNaN(x) || isNaN(y)) {
                    throw new Error('계산 결과가 유효한 숫자가 아닙니다.');
                }

                calculatedCoordinates[name] = { x: x, y: y };
            } catch (error) {
                console.error(`Error calculating coordinate ${name}: ${error.message}`);
                calculatedCoordinates[name] = { x: NaN, y: NaN };
            }
        }
    }

    function evaluateFormula(formula, calculatedPoints) {
        formula = formula.replace(/(\w+(?:\[\d+\])?)\.([xy])/g, function(match, point, coord) {
            if (calculatedPoints[point] && !isNaN(calculatedPoints[point][coord])) {
                return calculatedPoints[point][coord];
            }
            throw new Error(`유효하지 않은 좌표 참조: ${match}`);
        });

        formula = formula.replace(/\b([A-Za-z_]\w*)\b/g, function(match) {
            if (variables.hasOwnProperty(match)) {
                return variables[match];
            }
            return match;
        });

        var context = Object.assign({}, Math);
        
        try {
            var result = new Function('return ' + formula).call(context);
            if (typeof result !== 'number' || isNaN(result)) {
                throw new Error('계산 결과가 유효한 숫자가 아닙니다.');
            }
            return result;
        } catch (error) {
            throw new Error("수식 '" + formula + "' 계산 중 오류 발생: " + error.message);
        }
    }

    function findTopLevelComma(str) {
        var depth = 0;
        for (var i = 0; i < str.length; i++) {
            if (str[i] === '(') depth++;
            else if (str[i] === ')') depth--;
            else if (str[i] === ',' && depth === 0) return i;
        }
        return -1;
    }

    function resolveRangeValue(value) {
        value = value.trim();
        if (/^\d+$/.test(value)) return parseInt(value);
        if (variables.hasOwnProperty(value)) return variables[value];
        throw new Error('범위 값을 해석할 수 없습니다: ' + value);
    }

    function expandCoordinateRanges(inputText) {
        var lines = inputText.split('\n');
        var result = [];

        lines.forEach(function(line) {
            var trimmed = line.trim();
            if (!trimmed) { result.push(line); return; }

            // 세미콜론으로 주석 분리
            var commentIndex = trimmed.indexOf(';');
            var comment = '';
            var codePart = trimmed;
            if (commentIndex !== -1) {
                comment = ';' + trimmed.substring(commentIndex + 1);
                codePart = trimmed.substring(0, commentIndex).trim();
            }

            // 패턴: name[start-end]=formula
            var match = codePart.match(/^(\w+)\[([^\]-]+)-([^\]]+)\]=(.+)$/);
            if (!match) { result.push(line); return; }

            var baseName = match[1];
            var start = resolveRangeValue(match[2]);
            var end = resolveRangeValue(match[3]);
            var formula = match[4];

            for (var i = start; i <= end; i++) {
                // 수식 내의 'i'를 현재 인덱스로 치환 (단어 경계 기준)
                var expanded = formula.replace(/\bi\b/g, i);
                result.push(baseName + '[' + i + ']=' + expanded + comment);
            }
        });

        return result.join('\n');
    }

    function expandPointRanges(text) {
        return text.replace(/(\w+)\[([^\]-]+)-([^\]]+)\]/g, function(match, name, startStr, endStr) {
            try {
                var start = resolveRangeValue(startStr);
                var end = resolveRangeValue(endStr);
                var points = [];
                for (var i = start; i <= end; i++) {
                    points.push(name + '[' + i + ']');
                }
                return points.join(',');
            } catch (e) {
                return match; // 변환 실패 시 원본 유지
            }
        });
    }

    function expandPointSequence(text) {
        // 브라켓 표기: s[1]..s[20] 또는 s[0]..s[N] → s[1],s[2],...,s[20]
        text = text.replace(/(\w+)\[(\w+)\]\.\.\1\[(\w+)\]/g, function(match, name, startStr, endStr) {
            try {
                var start = resolveRangeValue(startStr);
                var end = resolveRangeValue(endStr);
                var points = [];
                var step = start <= end ? 1 : -1;
                for (var i = start; step > 0 ? i <= end : i >= end; i += step) {
                    points.push(name + '[' + i + ']');
                }
                return points.join(',');
            } catch (e) {
                return match;
            }
        });

        // 접미사 표기: p1..p10 → p1,p2,...,p10
        text = text.replace(/([A-Za-z_]\w*?)(\d+)\.\.\1(\d+)/g, function(match, prefix, startStr, endStr) {
            var start = parseInt(startStr);
            var end = parseInt(endStr);
            var points = [];
            var step = start <= end ? 1 : -1;
            for (var i = start; step > 0 ? i <= end : i >= end; i += step) {
                points.push(prefix + i);
            }
            return points.join(',');
        });

        return text;
    }



    function drawGraph() {
        calculateCoordinates();
        
        svg = d3.select("#graph");
        svg.selectAll("*").remove();

        var svgBounds = svg.node().getBoundingClientRect();
        var width = svgBounds.width;
        var height = svgBounds.height;
        var margin = { top: 20, right: 20, bottom: 20, left: 20 };
        var graphWidth = width - margin.left - margin.right;
        var graphHeight = height - margin.top - margin.bottom;

        svg.attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio", "xMidYMid meet");

        var domain = calculateDomain();

        // xScale과 yScale의 동일한 비율 설정
        var maxRange = Math.max(graphWidth, graphHeight);
        var xScaleRange = [0, maxRange];
        var yScaleRange = [maxRange, 0];

        xScale = d3.scaleLinear().domain(domain.x).range(xScaleRange);
        yScale = d3.scaleLinear().domain(domain.y).range(yScaleRange);

        // xScale = d3.scaleLinear().domain(domain.x).range([0, graphWidth]);
        // yScale = d3.scaleLinear().domain(domain.y).range([graphHeight, 0]);

        gContainer = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // 축 그리기
        drawAxes();

        // 줌 기능 설정
        zoom = d3.zoom()
            .scaleExtent([0.1, 100])
            .on("zoom", zoomed);

        svg.call(zoom);

        // 자동 zoom 조정
        autoZoom();

        // 모든 요소 그리기
        drawAllElements();
    }

    function drawAxes() {
        gContainer.append("g")
            .attr("class", "x-axis axis")
            .attr("transform", `translate(0,${yScale(0)})`)
            .call(d3.axisBottom(xScale).tickSize(0));
        gContainer.append("g")
            .attr("class", "y-axis axis")
            .attr("transform", `translate(${xScale(0)},0)`)
            .call(d3.axisLeft(yScale).tickSize(0));
    }

    function drawAllElements() {
        drawCoordinates();
        drawLines();
        drawDimensionLines();
    }

    function drawCoordinates() {
        gContainer.selectAll(".coordinate-group").remove();

        var dimScale = parseFloat(document.getElementById('dimScaleInput').value) || 1;
        var defaultTextHeight = 2.5; // 도면 단위 기본값
        var textHeightInUnits = defaultTextHeight * dimScale;

        // 도면 단위를 픽셀로 변환
        var pixelsPerUnit = Math.abs(xScale(1) - xScale(0));
        var fontSize = textHeightInUnits * pixelsPerUnit;
        var pointRadius = 0.5 * dimScale * pixelsPerUnit; // 직경 1 * dimScale
        var textOffset = textHeightInUnits * pixelsPerUnit * 0.8;

        Object.entries(calculatedCoordinates).forEach(function([name, coord]) {
            if (!isNaN(coord.x) && !isNaN(coord.y)) {
                var point = gContainer.append("g")
                    .attr("class", "coordinate-group")
                    .attr("transform", `translate(${xScale(coord.x)},${yScale(coord.y)})`);

                point.append("circle")
                    .attr("r", pointRadius)
                    .attr("fill", "black")
                    .attr("class", "coordinate-point")
                    .style("vector-effect", "non-scaling-stroke");

                point.append("text")
                    .attr("dy", -textOffset + "px")
                    .text(name)
                    .attr("class", "coordinate-label")
                    .style("text-anchor", "middle")
                    .style("font-size", fontSize + "px");
            }
        });
    }


    function drawLines() {
        gContainer.selectAll(".graph-line").remove();

        lines.forEach(function(line) {
            var start = calculatedCoordinates[line.start];
            var end = calculatedCoordinates[line.end];
            if (start && end && !isNaN(start.x) && !isNaN(start.y) && !isNaN(end.x) && !isNaN(end.y)) {
                gContainer.append("line")
                    .attr("class", "graph-line")
                    .attr("x1", xScale(start.x))
                    .attr("y1", yScale(start.y))
                    .attr("x2", xScale(end.x))
                    .attr("y2", yScale(end.y))
                    .attr("stroke", "blue")
                    .attr("stroke-width", 1 / zoom.transform.k)
                    .style("vector-effect", "non-scaling-stroke");
            }
        });
    }

    function drawDimensionLines() {
    gContainer.selectAll(".dimension-line, .dimension-text").remove();

    var currentZoom = zoom.transform ? zoom.transform.k : 1;
    var defaultOffset = 20;
    var dimScale = parseFloat(document.getElementById('dimScaleInput').value) || 1;

    dimensionLines.forEach(function(line) {
        if (!Array.isArray(line.points) || line.points.length < 2) {
            console.error('Invalid points for dimension line:', line.points);
            return;
        }

        var points = line.points.map(p => calculatedCoordinates[p]);
        if (points.some(p => !p || isNaN(p.x) || isNaN(p.y))) {
            console.error(`Invalid calculated coordinates for points: ${line.points}`);
            return;
        }

        var direction = typeof line.direction === 'number' ? line.direction : 1;
        var offset = defaultOffset * dimScale;

        if (line.type === 'HDIM') {
            drawHorizontalDimension(points, direction, offset);
        } else if (line.type === 'VDIM') {
            drawVerticalDimension(points, direction, offset);
        } else if (line.type === 'ADIM') {
            drawAngularDimension(points, direction, offset);
        } else {
            console.error(`Invalid dimension type: ${line.type}`);
        }
    });
}

    function drawArrowHead(group, x, y, angle, direction) {
        var arrowSize = 5;
        var arrowAngle = Math.PI / 6; // 30도

        // 화살표의 두 점 계산
        var x1 = x - arrowSize * Math.cos(angle * Math.PI / 180 - arrowAngle);
        var y1 = y - arrowSize * Math.sin(angle * Math.PI / 180 - arrowAngle);
        var x2 = x - arrowSize * Math.cos(angle * Math.PI / 180 + arrowAngle);
        var y2 = y - arrowSize * Math.sin(angle * Math.PI / 180 + arrowAngle);

        group.append("path")
            .attr("d", `M${x},${y} L${x1},${y1} L${x2},${y2} Z`)
            .attr("fill", "black")
            .attr("stroke", "none");
    }

    function drawEndpoint(group, x, y) {
        var dimScale = parseFloat(document.getElementById('dimScaleInput').value) || 1;
        var pixelsPerUnit = Math.abs(xScale(1) - xScale(0));
        var radius = 0.5 * dimScale * pixelsPerUnit; // 직경 1 * dimScale

        group.append("circle")
            .attr("cx", x)
            .attr("cy", y)
            .attr("r", radius)
            .attr("fill", "black");
    }

    function drawHorizontalDimension(points, direction, offset) {
    if (!Array.isArray(points) || points.length < 2) {
        console.error('drawHorizontalDimension: Invalid points', points);
        return;
    }

    var y = points[0].y;
    var textY = y + offset * direction;

    // 도면 단위로 텍스트 크기 계산
    var dimScale = parseFloat(document.getElementById('dimScaleInput').value) || 1;
    var defaultTextHeight = 2.5;
    var textHeightInUnits = defaultTextHeight * dimScale;
    var pixelsPerUnit = Math.abs(xScale(1) - xScale(0));
    var fontSize = textHeightInUnits * pixelsPerUnit;

    var strokeWidth = 1;

    // 모든 점의 x 좌표 수집
    var xCoords = points.map(p => p.x);

    // 치수보조선 시작 오프셋 (원점에서 10 * dimScale 떨어진 곳에서 시작)
    var extensionGap = 10 * dimScale;
    var extensionStartY = y + extensionGap * direction;

    // 각 점에서 치수선까지 수직선 그리기 (원점에서 gap만큼 떨어진 곳에서 시작)
    xCoords.forEach(x => {
        gContainer.append("line")
            .attr("class", "dimension-line")
            .attr("x1", xScale(x))
            .attr("y1", yScale(extensionStartY))
            .attr("x2", xScale(x))
            .attr("y2", yScale(textY))
            .attr("stroke", "red")
            .attr("stroke-width", strokeWidth)
            .style("vector-effect", "non-scaling-stroke");
    });

    // 전체 수평선 그리기
    var xMin = Math.min(...xCoords);
    var xMax = Math.max(...xCoords);
    gContainer.append("line")
        .attr("class", "dimension-line")
        .attr("x1", xScale(xMin))
        .attr("y1", yScale(textY))
        .attr("x2", xScale(xMax))
        .attr("y2", yScale(textY))
        .attr("stroke", "red")
        .attr("stroke-width", strokeWidth)
        .style("vector-effect", "non-scaling-stroke");

    // 연속된 점 쌍마다 텍스트 추가
    for (var i = 0; i < points.length - 1; i++) {
        var x1 = points[i].x;
        var x2 = points[i + 1].x;
        var midX = (x1 + x2) / 2;

        gContainer.append("text")
            .attr("class", "dimension-text")
            .attr("x", xScale(midX))
            .attr("y", yScale(textY))
            .attr("dy", "-0.5em")
            .text(Math.round(Math.abs(x2 - x1)))
            .attr("text-anchor", "middle")
            .attr("fill", "black")
            .style("font-size", `${fontSize}px`);
    }

    // 각 점에 끝점 표시
    xCoords.forEach(x => {
        drawEndpoint(gContainer, xScale(x), yScale(textY));
    });
}

function drawVerticalDimension(points, direction, offset) {
    if (!Array.isArray(points) || points.length < 2) {
        console.error('drawVerticalDimension: Invalid points', points);
        return;
    }

    var x = points[0].x;
    var textX = x + offset * direction;

    // 도면 단위로 텍스트 크기 계산
    var dimScale = parseFloat(document.getElementById('dimScaleInput').value) || 1;
    var defaultTextHeight = 2.5;
    var textHeightInUnits = defaultTextHeight * dimScale;
    var pixelsPerUnit = Math.abs(xScale(1) - xScale(0));
    var fontSize = textHeightInUnits * pixelsPerUnit;

    var strokeWidth = 1;

    // 모든 점의 y 좌표 수집
    var yCoords = points.map(p => p.y);

    var scaledTextX = xScale(textX);

    // 치수보조선 시작 오프셋 (원점에서 10 * dimScale 떨어진 곳에서 시작)
    var extensionGap = 10 * dimScale;
    var extensionStartX = x + extensionGap * direction;

    // 각 점에서 치수선까지 수평선 그리기 (원점에서 gap만큼 떨어진 곳에서 시작)
    yCoords.forEach(y => {
        gContainer.append("line")
            .attr("class", "dimension-line")
            .attr("x1", xScale(extensionStartX))
            .attr("y1", yScale(y))
            .attr("x2", scaledTextX)
            .attr("y2", yScale(y))
            .attr("stroke", "red")
            .attr("stroke-width", strokeWidth)
            .style("vector-effect", "non-scaling-stroke");
    });

    // 전체 수직선 그리기
    var yMin = Math.min(...yCoords);
    var yMax = Math.max(...yCoords);
    gContainer.append("line")
        .attr("class", "dimension-line")
        .attr("x1", scaledTextX)
        .attr("y1", yScale(yMin))
        .attr("x2", scaledTextX)
        .attr("y2", yScale(yMax))
        .attr("stroke", "red")
        .attr("stroke-width", strokeWidth)
        .style("vector-effect", "non-scaling-stroke");

    // 연속된 점 쌍마다 텍스트 추가
    for (var i = 0; i < points.length - 1; i++) {
        var y1 = points[i].y;
        var y2 = points[i + 1].y;
        var midY = (y1 + y2) / 2;
        var scaledMidY = yScale(midY);

        gContainer.append("text")
            .attr("class", "dimension-text")
            .attr("x", scaledTextX)
            .attr("y", scaledMidY)
            .attr("transform", `rotate(-90, ${scaledTextX}, ${scaledMidY}) translate(0, ${direction > 0 ? -5 : 5})`)
            .text(Math.round(Math.abs(y2 - y1)))
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .attr("fill", "black")
            .style("font-size", `${fontSize}px`);
    }

    // 각 점에 끝점 표시
    yCoords.forEach(y => {
        drawEndpoint(gContainer, scaledTextX, yScale(y));
    });
}


function drawAngularDimension(points, direction, offset) {
    if (!Array.isArray(points) || points.length < 2) {
        console.error('drawAngularDimension: Invalid points', points);
        return;
    }

    var p1 = points[0];
    var p2 = points[1];

    // 두 점 사이의 각도 계산
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    var angle = Math.atan2(dy, dx);

    // 두 점 사이의 실제 거리
    var distance = Math.sqrt(dx * dx + dy * dy);

    // 치수선 offset 방향 (선에 수직 방향)
    var perpAngle = angle + Math.PI / 2;
    var offsetX = offset * direction * Math.cos(perpAngle);
    var offsetY = offset * direction * Math.sin(perpAngle);

    // 치수선의 두 끝점
    var dimP1 = { x: p1.x + offsetX, y: p1.y + offsetY };
    var dimP2 = { x: p2.x + offsetX, y: p2.y + offsetY };

    // 도면 단위로 텍스트 크기 계산
    var dimScale = parseFloat(document.getElementById('dimScaleInput').value) || 1;
    var defaultTextHeight = 2.5;
    var textHeightInUnits = defaultTextHeight * dimScale;
    var pixelsPerUnit = Math.abs(xScale(1) - xScale(0));
    var fontSize = textHeightInUnits * pixelsPerUnit;

    var strokeWidth = 1;

    // 치수보조선 시작 오프셋 (원점에서 10 * dimScale 떨어진 곳에서 시작)
    var extensionGap = 10 * dimScale;
    var gapX = extensionGap * direction * Math.cos(perpAngle);
    var gapY = extensionGap * direction * Math.sin(perpAngle);

    // 치수보조선 시작점 (원점에서 gap만큼 떨어진 곳)
    var extStart1 = { x: p1.x + gapX, y: p1.y + gapY };
    var extStart2 = { x: p2.x + gapX, y: p2.y + gapY };

    // 원점에서 치수선까지 연결선 그리기 (gap만큼 떨어진 곳에서 시작)
    [{ from: extStart1, to: dimP1 }, { from: extStart2, to: dimP2 }].forEach(function(line) {
        gContainer.append("line")
            .attr("class", "dimension-line")
            .attr("x1", xScale(line.from.x))
            .attr("y1", yScale(line.from.y))
            .attr("x2", xScale(line.to.x))
            .attr("y2", yScale(line.to.y))
            .attr("stroke", "red")
            .attr("stroke-width", strokeWidth)
            .style("vector-effect", "non-scaling-stroke");
    });

    // 치수선 그리기
    gContainer.append("line")
        .attr("class", "dimension-line")
        .attr("x1", xScale(dimP1.x))
        .attr("y1", yScale(dimP1.y))
        .attr("x2", xScale(dimP2.x))
        .attr("y2", yScale(dimP2.y))
        .attr("stroke", "red")
        .attr("stroke-width", strokeWidth)
        .style("vector-effect", "non-scaling-stroke");

    // 텍스트 위치 (치수선 중앙)
    var textX = (dimP1.x + dimP2.x) / 2;
    var textY = (dimP1.y + dimP2.y) / 2;

    // 텍스트 회전 각도 (degree)
    var textAngle = angle * 180 / Math.PI;
    // 텍스트가 뒤집어지지 않도록 조정
    if (textAngle > 90 || textAngle < -90) {
        textAngle += 180;
    }

    // 텍스트 추가
    gContainer.append("text")
        .attr("class", "dimension-text")
        .attr("x", xScale(textX))
        .attr("y", yScale(textY))
        .attr("transform", `rotate(${-textAngle}, ${xScale(textX)}, ${yScale(textY)})`)
        .attr("dy", "-0.5em")
        .text(Math.round(distance))
        .attr("text-anchor", "middle")
        .attr("fill", "black")
        .style("font-size", `${fontSize}px`);

    // 끝점 표시
    drawEndpoint(gContainer, xScale(dimP1.x), yScale(dimP1.y));
    drawEndpoint(gContainer, xScale(dimP2.x), yScale(dimP2.y));
}

function zoomed(event) {
    if (!event.transform) {
        console.error("Zoom event transform is undefined");
        return;
    }

    gContainer.attr("transform", event.transform);

    // 축 업데이트
    gContainer.select(".x-axis").call(d3.axisBottom(event.transform.rescaleX(xScale)).tickSize(0));
    gContainer.select(".y-axis").call(d3.axisLeft(event.transform.rescaleY(yScale)).tickSize(0));

    // 모든 요소 다시 그리기
    drawAllElements();
}


function calculateDomain() {
    var allPoints = Object.values(calculatedCoordinates).filter(point => point && !isNaN(point.x) && !isNaN(point.y));
    
    if (allPoints.length === 0) return { x: [-10, 10], y: [-10, 10] };

    var xExtent = d3.extent(allPoints, d => d.x);
    var yExtent = d3.extent(allPoints, d => d.y);

    var xPadding = Math.max((xExtent[1] - xExtent[0]) * 0.1, 1);
    var yPadding = Math.max((yExtent[1] - yExtent[0]) * 0.1, 1);

    return {
        x: [xExtent[0] - xPadding, xExtent[1] + xPadding],
        y: [yExtent[0] - yPadding, yExtent[1] + yPadding]
    };
}

function autoZoom() {
    var domain = calculateDomain();
    var svgBounds = svg.node().getBoundingClientRect();
    var width = svgBounds.width;
    var height = svgBounds.height;
    var margin = 40; // 여백

    var xRange = domain.x[1] - domain.x[0];
    var yRange = domain.y[1] - domain.y[0];

    // 바운딩박스에 맞게 스케일 계산
    var scaleX = (width - margin * 2) / (xScale(domain.x[1]) - xScale(domain.x[0]));
    var scaleY = (height - margin * 2) / (yScale(domain.y[0]) - yScale(domain.y[1]));
    var scale = Math.min(scaleX, scaleY);
    scale = Math.max(scale, 0.001); // 최소 스케일 보장

    var centerX = (domain.x[0] + domain.x[1]) / 2;
    var centerY = (domain.y[0] + domain.y[1]) / 2;

    var transform = d3.zoomIdentity
        .translate(width / 2, height / 2)
        .scale(scale)
        .translate(-xScale(centerX), -yScale(centerY));

    svg.transition().duration(750).call(zoom.transform, transform);
}

function setScale() {
    if (svg && zoom) {
        drawGraph();
    }
}




function toggleLabels() {
    showLabels = document.getElementById('showLabelsToggle').checked;
    d3.selectAll('.coordinate-label, .coordinate-point').style('display', showLabels ? 'inline' : 'none');
}

function printGraphInfo() {
    var graphInfo = {
        variables: variables,
        variableComments: variableComments,
        coordinates: userCoordinates,
        coordinateComments: coordinateComments,
        calculatedCoordinates: calculatedCoordinates,
        lines: lines,
        lineGroups: lineGroups,
        dimensionLines: dimensionLines
    };

    var jsonString = JSON.stringify(graphInfo, null, 2);
    document.getElementById('graphInfo').value = jsonString;
}

function printTextInfo() {
    var textLines = [];

    Object.entries(variables).forEach(function([name, value]) {
        var comment = variableComments[name] ? ';' + variableComments[name] : '';
        textLines.push(name + '=' + value + comment);
    });
    Object.entries(userCoordinates).forEach(function([name, coord]) {
        var comment = coordinateComments[name] ? ';' + coordinateComments[name] : '';
        textLines.push(name + '=' + coord.x + ',' + coord.y + comment);
    });
    lineGroups.forEach(function(group) {
        var comment = group.comment ? ';' + group.comment : '';
        textLines.push('line,' + group.points.join(',') + comment);
    });
    dimensionLines.forEach(function(dim) {
        var comment = dim.comment ? ';' + dim.comment : '';
        textLines.push(dim.type + ',' + dim.direction + ',' + dim.points.join(',') + comment);
    });

    document.getElementById('graphInfo').value = textLines.join('\n');
}

function downloadData() {
    var content = document.getElementById('graphInfo').value.trim();
    if (!content) {
        alert('다운로드할 데이터가 없습니다. JSON보기 또는 TEXT보기를 먼저 클릭하세요.');
        return;
    }

    var isJson = content.startsWith('{');
    var extension = isJson ? 'json' : 'txt';
    var mimeType = isJson ? 'application/json' : 'text/plain';
    var filename = 'paradraw_data.' + extension;

    var blob = new Blob([content], { type: mimeType + ';charset=utf-8' });
    var url = URL.createObjectURL(blob);

    var a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function uploadData(event) {
    var file = event.target.files[0];
    if (!file) return;

    var reader = new FileReader();
    reader.onload = function(e) {
        document.getElementById('graphInfo').value = e.target.result;
        readGraphInfo();
    };
    reader.readAsText(file);

    // 같은 파일을 다시 선택할 수 있도록 초기화
    event.target.value = '';
}

function loadExampleData(silent) {
    var selected = document.getElementById('exampleSelect').value;
    var examples = getExampleDataMap();
    var example = examples[selected];
    if (!example) return;

    document.getElementById('mainInput').value = example.text;
    document.getElementById('graphInfo').value = '';
    parseAllInput();
    drawGraph();
}

function getExampleDataMap() {
    return {
        retaining: {
            text: [
                'H1=2000;흉벽높이',
                'H2=3000;벽체높이',
                'H3=1200;기초두께',
                'B1=2500;뒷굽폭',
                'B2=2000;벽체두께',
                'B3=1200;앞굽폭',
                'B4=500;흉벽두께',
                'p1=0,0',
                'p2=p1.x,p1.y-H1',
                'p3=p2.x+B2-B4,p2.y',
                'p4=p3.x,p3.y-H2',
                'p5=p4.x+B3,p4.y',
                'p6=p5.x,p5.y-H3',
                'p7=p6.x-B3-B2-B1,p6.y',
                'p8=p7.x,p7.y+H3',
                'p9=p8.x+B1,p8.y',
                'p10=p9.x,p1.y',
                'line,p1..p10,p1;외벽',
                'HDIM,-1,p7,p6;전체폭',
                'HDIM,1,p8,p9,p4,p5;상부폭',
                'HDIM,1,p10,p1,p3;흉벽폭',
                'VDIM,1,p6,p1;전체높이'
            ].join('\n')
        },
        sine: {
            text: [
                'A=500;진폭',
                'L=2000;길이',
                'N=20;분할수',
                's[0-N]=L/N*i,A*Math.sin(2*Math.PI*i/N);sin곡선',
                'line,s[0]..s[N]'
            ].join('\n')
        },
        circle: {
            text: [
                'R=500;반지름',
                'N=36;분할수',
                'c[0-N]=R*Math.cos(2*Math.PI*i/N),R*Math.sin(2*Math.PI*i/N);원',
                'line,c[0]..c[N],c[0]'
            ].join('\n')
        },
        heart: {
            text: [
                'S=30;크기',
                'N=72;분할수',
                'h[0-N]=S*16*Math.pow(Math.sin(2*Math.PI*i/N),3),S*(13*Math.cos(2*Math.PI*i/N)-5*Math.cos(4*Math.PI*i/N)-2*Math.cos(6*Math.PI*i/N)-Math.cos(8*Math.PI*i/N));하트',
                'line,h[0]..h[N],h[0]'
            ].join('\n')
        }
    };
}

function readGraphInfo(silent) {
    var inputText = document.getElementById('graphInfo').value.trim();

    // JSON인지 TEXT인지 판단 (첫 문자가 {이면 JSON)
    if (inputText.startsWith('{')) {
        readJsonData(inputText, silent);
    } else {
        readTextData(inputText, silent);
    }
}

function readJsonData(jsonString, silent) {
    try {
        var graphInfo = JSON.parse(jsonString);

        variables = graphInfo.variables || {};
        variableComments = graphInfo.variableComments || {};
        userCoordinates = graphInfo.coordinates || {};
        coordinateComments = graphInfo.coordinateComments || {};
        calculatedCoordinates = graphInfo.calculatedCoordinates || {};
        lines = graphInfo.lines || [];
        dimensionLines = graphInfo.dimensionLines || [];

        // lineGroups 처리: 있으면 사용, 없으면 lines에서 생성
        if (graphInfo.lineGroups && graphInfo.lineGroups.length > 0) {
            lineGroups = graphInfo.lineGroups;
        } else {
            // 기존 lines 배열에서 lineGroups 생성
            lineGroups = [];
            if (lines.length > 0) {
                var currentGroup = { points: [lines[0].start, lines[0].end], comment: '' };
                for (var i = 1; i < lines.length; i++) {
                    if (lines[i].start === currentGroup.points[currentGroup.points.length - 1]) {
                        currentGroup.points.push(lines[i].end);
                    } else {
                        lineGroups.push(currentGroup);
                        currentGroup = { points: [lines[i].start, lines[i].end], comment: '' };
                    }
                }
                lineGroups.push(currentGroup);
            }
        }

        applyLoadedData(silent, 'JSON');
    } catch (error) {
        console.error('JSON 파싱 에러:', error);
        if (!silent) {
            alert('JSON 데이터를 읽는 중 오류가 발생했습니다. 올바른 형식인지 확인해주세요.');
        }
    }
}

function readTextData(textContent, silent) {
    try {
        document.getElementById('mainInput').value = textContent;
        parseAllInput();
        drawGraph();
        if (!silent) {
            alert('TEXT 데이터를 성공적으로 읽어 적용했습니다.');
        }
    } catch (error) {
        console.error('TEXT 파싱 에러:', error);
        if (!silent) {
            alert('TEXT 데이터를 읽는 중 오류가 발생했습니다. 올바른 형식인지 확인해주세요.');
        }
    }
}

function applyLoadedData(silent, format) {
    updateMainInput();
    updateParseResult();
    calculateCoordinates();
    drawGraph();

    if (!silent) {
        alert(format + ' 데이터를 성공적으로 읽어 적용했습니다.');
    }
}

// 전역 객체에 함수 할당
window.applyAndDraw = applyAndDraw;
window.drawGraph = drawGraph;
window.toggleLabels = toggleLabels;
window.setScale = setScale;
window.printGraphInfo = printGraphInfo;
window.printTextInfo = printTextInfo;
window.downloadData = downloadData;
window.uploadData = uploadData;
window.readGraphInfo = readGraphInfo;
window.loadExampleData = loadExampleData;

// 초기화 함수
function init() {
    loadExampleData(true);
}

// 페이지 로드 시 초기화
window.onload = init;
})();

</script>
    </body>
    </html>